"""
dynamo_backend.migration_writer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Turns a list of Operation objects into a migration file and writes it to
  <app_dir>/dynamo_migrations/<number>_<slug>.py

Public API::

    writer = MigrationWriter(app_label, operations, dependencies)
    path   = writer.write()          # creates file, returns abs path
    text   = writer.as_string()      # preview without writing
"""

from __future__ import annotations

import os
import re
from textwrap import indent
from typing import Any, List, Optional, Tuple, Dict

from .migration_ops import (
    Operation, CreateTable, AddField, RemoveField, AlterField,
    AddIndex, RemoveIndex,
)
from .migration_fields import field_to_dict


# ─────────────────────────────────────────────────── field repr helpers

def _repr_value(v: Any) -> str:
    """Return a Python-literal representation of a value."""
    if v is None:
        return "None"
    if isinstance(v, bool):
        return str(v)
    if isinstance(v, (int, float)):
        return repr(v)
    if isinstance(v, str):
        return repr(v)
    if isinstance(v, list):
        items = ", ".join(_repr_value(i) for i in v)
        return f"[{items}]"
    if isinstance(v, dict):
        pairs = ", ".join(f"{repr(k)}: {_repr_value(vv)}" for k, vv in v.items())
        return "{" + pairs + "}"
    return repr(v)


def _field_constructor(fd: Dict) -> str:
    """Render a field dict back to a Python constructor expression."""
    ftype = fd["type"]
    kwargs = fd.get("kwargs", {})
    kwarg_str = ", ".join(f"{k}={_repr_value(v)}" for k, v in kwargs.items())
    return f"fields.{ftype}({kwarg_str})"


# ─────────────────────────────────────────────────── op → source lines

def _op_source(op: Operation) -> List[str]:
    """Return the source lines for a single operation."""
    if isinstance(op, CreateTable):
        field_lines = [
            f"            ({repr(name)}, {_field_constructor(field_to_dict(f))})"
            for name, f in (op.fields or [])
        ]
        fields_block = "[\n" + ",\n".join(field_lines) + "\n        ]" if field_lines else "[]"
        return [
            "        migrations.CreateTable(",
            f"            app_label={repr(op.app_label)},",
            f"            model_name={repr(op.model_name)},",
            f"            table_name={repr(op.table_name)},",
            f"            fields={fields_block},",
            "        ),",
        ]

    if isinstance(op, AddField):
        fd = field_to_dict(op.field)
        return [
            "        migrations.AddField(",
            f"            app_label={repr(op.app_label)},",
            f"            model_name={repr(op.model_name)},",
            f"            field_name={repr(op.field_name)},",
            f"            field={_field_constructor(fd)},",
            "        ),",
        ]

    if isinstance(op, RemoveField):
        return [
            "        migrations.RemoveField(",
            f"            app_label={repr(op.app_label)},",
            f"            model_name={repr(op.model_name)},",
            f"            field_name={repr(op.field_name)},",
            "        ),",
        ]

    if isinstance(op, AlterField):
        fd = field_to_dict(op.field)
        return [
            "        migrations.AlterField(",
            f"            app_label={repr(op.app_label)},",
            f"            model_name={repr(op.model_name)},",
            f"            field_name={repr(op.field_name)},",
            f"            field={_field_constructor(fd)},",
            "        ),",
        ]

    if isinstance(op, AddIndex):
        return [
            "        migrations.AddIndex(",
            f"            app_label={repr(op.app_label)},",
            f"            model_name={repr(op.model_name)},",
            f"            field_name={repr(op.field_name)},",
            "        ),",
        ]

    if isinstance(op, RemoveIndex):
        return [
            "        migrations.RemoveIndex(",
            f"            app_label={repr(op.app_label)},",
            f"            model_name={repr(op.model_name)},",
            f"            field_name={repr(op.field_name)},",
            "        ),",
        ]

    raise ValueError(f"Unknown operation type: {type(op)}")


# ─────────────────────────────────────────────────── writer class

class MigrationWriter:
    def __init__(
        self,
        app_label: str,
        migration_name: str,   # e.g. "0001_initial"
        operations: List[Operation],
        dependencies: Optional[List[Tuple[str, str]]] = None,
    ):
        self.app_label = app_label
        self.migration_name = migration_name
        self.operations = operations
        self.dependencies = dependencies or []

    # ---------------------------------------------------------------- rendering

    def as_string(self) -> str:
        lines: List[str] = [
            "# Generated by dynamo_backend migration system.",
            "# Do not edit manually unless you know what you are doing.",
            "",
            "from dynamo_backend import migration_ops as migrations",
            "from dynamo_backend import fields",
            "",
            "",
            "class Migration:",
        ]

        # dependencies
        if self.dependencies:
            dep_items = ", ".join(
                f"({repr(a)}, {repr(n)})" for a, n in self.dependencies
            )
            lines.append(f"    dependencies = [{dep_items}]")
        else:
            lines.append("    dependencies = []")

        lines.append("")
        lines.append("    operations = [")
        for op in self.operations:
            lines.extend(_op_source(op))
        lines.append("    ]")

        return "\n".join(lines) + "\n"

    # ---------------------------------------------------------------- writing

    def write(self, app_path: str) -> str:
        """
        Write the migration file to  <app_path>/dynamo_migrations/<name>.py
        and create an __init__.py in that directory if needed.
        Returns the absolute path of the newly created file.
        """
        mig_dir = os.path.join(app_path, "dynamo_migrations")
        os.makedirs(mig_dir, exist_ok=True)

        init_path = os.path.join(mig_dir, "__init__.py")
        if not os.path.exists(init_path):
            with open(init_path, "w") as f:
                f.write("# dynamo migrations package\n")

        file_path = os.path.join(mig_dir, f"{self.migration_name}.py")
        with open(file_path, "w") as f:
            f.write(self.as_string())

        return file_path
